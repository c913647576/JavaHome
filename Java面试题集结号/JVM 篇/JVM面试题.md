### JVM 篇 ###
#### 1. 什么情况下会发生栈内存溢出。什么时候发生堆溢出？你是怎么排错的？  ####
- 栈内存溢出

	栈是线程私有的，他的生命周期与线程相同，每个方法在执行的时候都会创建一个栈帧，用来存储局部变量表，操作数栈，动态链接，方法出口等信息。局部变量表又包含基本数据类型，对象引用类型（局部变量表编译器完成，运行期间不会变化）。所以我们可以理解为栈溢出就是方法执行是创建的栈帧请求的深度超过了栈能给予的最大深度。最有可能的就是：递归方法调用产生这种结果。

	![](https://img-blog.csdnimg.cn/20200801195942598.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ZyaXN0amNqZG5jZw==,size_16,color_FFFFFF,t_70)

	解决：我们需要使用参数 -Xss 去调整JVM栈的大小

	![](https://img-blog.csdnimg.cn/20200801200243402.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ZyaXN0amNqZG5jZw==,size_16,color_FFFFFF,t_70)

- 堆内存溢出

	![](https://img-blog.csdnimg.cn/20200801200416915.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ZyaXN0amNqZG5jZw==,size_16,color_FFFFFF,t_70)

	（1）静态集合类，如HashMap、LinkedList等等。如果这些容器为静态的，那么它们的生命周期与程序一致，则容器中的对象在程序结束之前将不能被释放，从而造成内存泄漏。简单而言，长生命周期的对象持有短生命周期对象的引用，尽管短生命周期的对象不再使用，但是因为长生命周期对象持有它的引用而导致不能被回收。

	（2）数据库连接、网络连接和IO连接等。在对数据库进行操作的过程中，首先需要建立与数据库的连接，当不再使用时，需要调用close方法来释放与数据库的连接。只有连接被关闭后，垃圾回收器才会回收对应的对象。否则，如果在访问数据库的过程中，对Connection、Statement或ResultSet不显性地关闭，将会造成大量的对象无法被回收，从而引起内存泄漏。

	（3）变量不合理的作用域。一般而言，一个变量的定义的作用范围大于其使用范围，很有可能会造成内存泄漏。另一方面，如果没有及时地把对象设置为null，很有可能导致内存泄漏的发生。

- 永久代溢出(OutOfMemoryError: PermGen space)
	由于JDK7、8移除永久带，所以上述代码在JDK1.6的情况中会出现永久带溢出的现象。

#### 2. JVM怎么判断对象是可回收对象？有哪些方法。 ####
- 引用计数法

    给每一个对象添加一个引用计数器，当一个引用指向对象，计数器值加一，当一个引用失效，计数器减一，判断计数器是否为0，确定对象是否可用。

- 可达性分析(Reachability Analysis) 

    从GC Roots开始搜索，关联到的对象存活，没有关联到的可以回收。

![](https://pic1.zhimg.com/80/v2-e980fa21a25bf85be0523f72d61d8d40_720w.jpg)
#### 3. 哪些对象可以作为GC Roots(Garbage Collection Roots)？ ####
- 虚拟机栈中引用的对象
- 方法区中类静态属性引用的对象
- 方法区中常量引用的对象
- 本地方法栈中JNI(native方法，调用C++代码)引用的对象
#### 4. JVM的内存结构，新生代与老年代的比例，Eden和Survivor比例。
JVM内存结果如图：
![](https://images2015.cnblogs.com/blog/1135193/201704/1135193-20170404105818910-121962267.jpg)

内存比例如图：
![](https://images0.cnblogs.com/blog/587773/201409/061921034534396.png)

从图中可以看出： 堆大小 = 新生代 + 老年代。其中，堆的大小可以通过参数 –Xms、-Xmx 来指定。
默认的，新生代 ( Young ) 与老年代 ( Old ) 的比例的值为 1:2 ( 该值可以通过参数 –XX:NewRatio 来指定 )，即：新生代 ( Young ) = 1/3 的堆空间大小。老年代 ( Old ) = 2/3 的堆空间大小。其中，新生代 ( Young ) 被细分为 Eden 和 两个 Survivor 区域，这两个 Survivor 区域分别被命名为 from 和 to，以示区分。
默认的，Eden : from : to = 8 : 1 : 1 ( 可以通过参数 –XX:SurvivorRatio 来设定 )，即： Eden = 8/10 的新生代空间大小，from = to = 1/10 的新生代空间大小。
JVM 每次只会使用 Eden 和其中的一块 Survivor 区域来为对象服务，所以无论什么时候，总是有一块 Survivor 区域是空闲着的。
因此，新生代实际可用的内存空间为 9/10 ( 即90% )的新生代空间。
#### 5. 你知道哪几种垃圾收集器，各自的优缺点，重点讲下cms和G1，包括原理，流程，优缺点。 ####
几种垃圾收集器：

Serial收集器：单线程的收集器，收集垃圾时，必须stop-the-world，使用复制算法。

ParNew收集器：Serial收集器的多线程版本，也需要stop-the-world，复制算法。

ParallelScavenge收集器：新生代收集器，复制算法的收集器，并发的多线程收集器，目标是达到一个 可控的吞吐量。如果虚拟机总共运行100分钟，其中垃圾花掉1分钟，吞吐量就是99%。

SerialOld收集器：是Serial收集器的老年代版本，单线程收集器，使用标记整理算法。

ParallelOld收集器：是ParallelScavenge收集器的老年代版本，使用多线程，标记-整理算法。

CMS(ConcurrentMarkSweep)收集器：是一种以获得最短回收停顿时间为目标的收集器，标记清除算法，运作过程：初始标记(stop-the-world)，并发标记，重新标记(stop-the-world)，并发清除。优点，并发执行，停顿时间短。缺点，收集结束会产生大量空间碎片。

G1收集器：标记整理算法实现，运作流程主要包括以下：初始标记(stop-the-world)，并发标记，最终标记(stop-the-world)，筛选回收(stop-the-world)。优点，(1) 基于标记-整理算法，不产生内存碎片。(2) 可以非常精确控制停顿时间，在不牺牲吞吐量前提下，实现低停顿垃圾回收。

G1 收集器避免全区域垃圾收集，它把堆内存划分为大小固定的几个独立区域，并且跟踪这些区域
的垃圾收集进度，同时在后台维护一个优先级列表，每次根据所允许的收集时间，优先回收垃圾
最多的区域。区域划分和优先级区域回收机制，确保 G1 收集器可以在有限时间获得最高的垃圾收
集效率。


#### 6. 简单说说你了解的类加载器，可以打破双亲委派么，怎么打破。 ####
- 简单说，类加载器根据指定的全限定名称将class文件加载到JVM内存，转为Class对象。

	类加载器主要分四种：
		**启动类加载器**（Bootstrap ClassLoader）：由C++语言实现（针对HotSpot）,负责将存放在<JAVA_HOME>\lib目录或-Xbootclasspath参数指定的路径中的类库加载到内存中。
		**扩展类加载器**（Extension ClassLoader）：负责加载<JAVA_HOME>\lib\ext目录或java.ext.dirs系统变量指定的路径中的所有类库。
		**应用程序类加载器**（Application ClassLoader）。负责加载用户类路径（classpath）上的指定类库，我们可以直接使用这个类加载器。一般情况，如果我们没有自定义类加载器默认就是用这个加载器。
		**自定义加载器**（Customer ClassLoader）。	**双亲委派模型工作过程**：如果一个类加载器收到类加载的请求，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器完成。每个类加载器都是如此，只有当父加载器在自己的搜索范围内找不到指定的类时（即ClassNotFoundException），子加载器才会尝试自己去加载。

- 打破双亲委派机制要继承ClassLoader类，并重写loadClass和findClass方法。默认的loadClass方法是实现了双亲委派机制的逻辑，即会先让父类加载器加载，当无法加载时才由自己加载。这里为了破坏双亲委派机制必须重写loadClass方法，即这里先尝试交由System类加载器加载，加载失败才会由自己加载。它并没有优先交给父类加载器，这就打破了双亲委派机制。

#### 7. JVM内存为什么要分成新生代，老年代，持久代。新生代中为什么要分为Eden和Survivor。 ####

**分代的作用**：因为有的对象寿命长，有的对象寿命短。应该将寿命长的对象放在一个区，寿命短的对象放在一个区。不同的区采用不同的垃圾收集算法。寿命短的区清理频次高一点，寿命长的区清理频次低一点。提高效率。

**Survivor的作用**：将Eden区满了的对象，添加到Survivor区，等对象反复清理几遍之后都没清理掉，再放到老年区，这样老年区的压力就会小很多。即Survivor相当于一个筛子，筛掉生命周期短的，将生命周期长的放到老年代区，减少老年代被清理的次数。

**为什么存在两个Survivor**:避免产生内存碎片。为了不产生内存碎片，才用复制算法，将Eden区和Survivor区存活的对象整齐的放到一个空的内存。因为生命周期一般都比较短，所以在存活对象不多的情况下，复制算法效率还是比较高的,这样就需要一个空内存，而如果有三个区，这样就总可以保持一个是空的，这样清理垃圾的时候，就可以将存活对象全部都整齐的放到一个空的内存中，不产生内存碎片了。

#### 8. JVM 出现 fullGC 很频繁，怎么去线上排查问题？ ####

- jstat 查看GC信息观察GC后的堆空间大小并判断是否空间不足导致

	空间不足导致：拿到 dump 文件，放入 JVisualVM 观察原因

	空间充足：观察程序中有没显示调用 System.gc() 方法

#### 9. JVM中一次完整的GC流程是怎样的，对象如何晋升到老年代，说说你知道的几种主要的JVM参数。 ####

思路： 先描述一下Java堆内存划分，再解释Minor GC，Major GC，full GC，描述它们之间转化流程。

我的答案：

Java堆 = 老年代 + 新生代

新生代 = Eden + S0 + S1

当 Eden 区的空间满了， Java虚拟机会触发一次 Minor GC，以收集新生代的垃圾，存活下来的对象，则会转移到 Survivor区。

大对象（需要大量连续内存空间的Java对象，如那种很长的字符串）直接进入老年态；

如果对象在Eden出生，并经过第一次Minor GC后仍然存活，并且被Survivor容纳的话，年龄设为1，每熬过一次Minor GC，年龄+1，若年龄超过一定限制（15），则被晋升到老年态。即长期存活的对象进入老年态。

老年代满了而无法容纳更多的对象，Minor GC 之后通常就会进行Full GC，Full GC 清理整个内存堆 – 包括年轻代和年老代。

Major GC 发生在老年代的GC，清理老年区，经常会伴随至少一次Minor GC，比Minor GC慢10倍以上。

#### 10. 垃圾回收算法的实现原理。 ####

需要具体说明哪个垃圾回收算法；

11. JVM内存模型的相关知识了解多少，比如重排序，内存屏障，happen-before，主内存，工作内存等。
12. 说一下Java对象的创建过程
13. 你们线上应用的JVM参数配置了哪些。
#### 14. CMS和G1收集器的区别。 ####
CMS收集器是老年代的收集器，可以配合新生代的Serial和ParNew收 集器一起使用；G1收集器收集范围是老年代和新生代，不需要结合其他收集器使用；
CMS收集器以小的停顿时间为目标的收集器；G1收集器可预测垃圾回收的停顿时间CMS收集器是使用“标记-清除”算 法进行的垃圾回收，容易产生内存碎片G1收集器使用的是“标记-整理”算法，进行了空间整合，降低了内存空间碎片。

#### 15. 怎么打出线程栈信息。 ####

- jstack [pid] > xxx.txt：打印堆栈信息到文件
- jstack -l [pid] > xxx.txt：打印堆栈信息（包含锁）到文件
- kill -3
- 添加 JVM 参数：-XX:+HEAPDUMPONOUTOFMEMORYERROR（在内存溢出是保存堆栈信息），一般配合 -XX:HeapDumpPath=PATH 使用（可用 jinfo 命令运行时修改）
- jmap -dump:format=b,file=xxx.dump [pid]

#### 16. 说一下类加载的执行过程 ####

JVM不是一开始就把所有的类都加载进内存中，而是只有第一次遇到某个需要运行的类时才会加载，且只加载一次。

类加载的过程主要分为三个部分：加载、链接、初始化。而链接又可以细分为三个小部分：验证、准备、解析。

**加载**

简单来说，加载指的是把class字节码文件从各个来源通过类加载器装载入内存中。

这里有两个重点：

字节码来源。一般的加载来源包括从本地路径下编译生成的.class文件，从jar包中的.class文件，从远程网络，以及动态代理实时编译

类加载器。一般包括启动类加载器，扩展类加载器，应用类加载器，以及用户的自定义类加载器。

注：为什么会有自定义类加载器？

一方面是由于java代码很容易被反编译，如果需要对自己的代码加密的话，可以对编译后的代码进行加密，然后再通过实现自己的自定义类加载器进行解密，最后再加载。

另一方面也有可能从非标准的来源加载代码，比如从网络来源，那就需要自己实现一个类加载器，从指定源进行加载。

**验证**

主要是为了保证加载进来的字节流符合虚拟机规范，不会造成安全错误。

包括对于文件格式的验证，比如常量中是否有不被支持的常量？文件中是否有不规范的或者附加的其他信息？

对于元数据的验证，比如该类是否继承了被final修饰的类？类中的字段，方法是否与父类冲突？是否出现了不合理的重载？

对于字节码的验证，保证程序语义的合理性，比如要保证类型转换的合理性。

对于符号引用的验证，比如校验符号引用中通过全限定名是否能够找到对应的类？校验符号引用中的访问性（private，public等）是否可被当前类访问？

**准备**

主要是为类变量（注意，不是实例变量）分配内存，并且赋予初值。

特别需要注意，初值，不是代码中具体写的初始化的值，而是Java虚拟机根据不同变量类型的默认初始值。

比如8种基本类型的初值，默认为0；引用类型的初值则为null；常量的初值即为代码中设置的值，final static tmp = 456， 那么该阶段tmp的初值就是456

**解析**

将常量池内的符号引用替换为直接引用的过程。

两个重点：

符号引用。即一个字符串，但是这个字符串给出了一些能够唯一性识别一个方法，一个变量，一个类的相关信息。

直接引用。可以理解为一个内存地址，或者一个偏移量。比如类方法，类变量的直接引用是指向方法区的指针；而实例方法，实例变量的直接引用则是从实例的头指针开始算起到这个实例变量位置的偏移量

举个例子来说，现在调用方法hello()，这个方法的地址是1234567，那么hello就是符号引用，1234567就是直接引用。

在解析阶段，虚拟机会把所有的类名，方法名，字段名这些符号引用替换为具体的内存地址或偏移量，也就是直接引用。

**初始化**

这个阶段主要是对类变量初始化，是执行类构造器的过程。

换句话说，只对static修饰的变量或语句进行初始化。

如果初始化一个类的时候，其父类尚未初始化，则优先初始化其父类。

如果同时包含多个静态变量和静态代码块，则按照自上而下的顺序依次执行。

#### 17. JVM垃圾回收机制，何时触发MinorGC等操作呢？ ####


#### 18. ZGC 垃圾收集器，了解过吗 ####


#### 19. 对象的访问定位有哪两种方式? ####

- 句柄：在堆空间中开辟一块空间用来存放句柄池，句柄池存放对象的类型指针和对象的实例指针，reference指针指向句柄

	**好处**：reference指向稳定的句柄，当堆空间进行gc时，对象的移动只会改变句柄中的对象实例指针，对reference没有影响

![](https://images1.pianshen.com/224/91/91ec7710bde4593d2da392f40eac4558.png)

- 直接指针：堆中实例对象存放实例类型，reference指针直接指向实例对象

	**好处**：速度更快，节省一次指针定位的开销

![](https://images3.pianshen.com/701/94/94f8585fd609ee64b0ec9bec634f0ff5.png)

#### 20. 类卸载条件？ ####
类卸载即该类的class对象被GC

- 该类的所有的实例对象都被GC，即堆中不存在该类的实例对象
- 该类没有在其他地方被引用
- 该类的类加载器的实例已被GC

#### 21. 说一下 jvm 调优的工具？ ####


#### 22. 对象什么时候会进入老年代？ ####

思路： 先描述一下Java堆内存划分，再解释Minor GC，Major GC，full GC，描述它们之间转化流程。

我的答案：

- Java堆 = 老年代 + 新生代
- 新生代 = Eden + S0 + S1
- 当 Eden 区的空间满了， Java虚拟机会触发一次 Minor GC，以收集新生代的垃圾，存活下来的对象，则会转移到 Survivor区。
- 大对象（需要大量连续内存空间的Java对象，如那种很长的字符串）直接进入老年态；
- 如果对象在Eden出生，并经过第一次Minor GC后仍然存活，并且被Survivor容纳的话，年龄设为1，每熬过一次Minor GC，年龄+1，若年龄超过一定限制（15），则被晋升到老年态。即长期存活的对象进入老年态。
- 老年代满了而无法容纳更多的对象，Minor GC 之后通常就会进行Full GC，Full GC 清理整个内存堆 – 包括年轻代和年老代。
- Major GC 发生在老年代的GC，清理老年区，经常会伴随至少一次Minor GC，比Minor GC慢10倍以上。

#### 23. 内存泄漏和内存溢出区别？ ####
- 内存溢出就是指程序运行过程中，申请的内存大于系统能够提供的内存，导致无法申请到足够的内存，就会发生内存溢出。
- 内存泄漏是指程序运行过程中分配内存给临时变量，用完之后却没有被GC回收，始终占用着内存，既不能被使用也不能分配给其他程序，就发生了内存泄漏。
#### 24. 什么是tomcat类加载机制？ ####

#### 25. 了解逃逸分析技术吗 ####


#### 26. 调用System.gc()会发生什么? ####
调用System.gc()方法会提示JVM进行Full GC垃圾回收。但是，立即开始还是延迟进行垃圾回收是取决于JVM的。在进行Full GC之前会先进行Minor GC。
#### 27. 谈谈Minor GC条件，full GC条件 ####
**触发MinorGC(Young GC)**

虚拟机在进行minorGC之前会判断老年代最大的可用连续空间是否大于新生代的所有对象总空间

- 如果大于的话，直接执行minorGC
- 如果小于，判断是否开启HandlerPromotionFailure（分配担保机制），没有开启直接FullGC
- 如果开启了HanlerPromotionFailure, JVM会判断老年代的最大连续内存空间是否大于历次晋升的大小，如果小于直接执行FullGC
- 如果大于的话，执行minorGC

**触发FullGC**

- 老年代空间不足

     如果创建一个大对象，Eden区域当中放不下这个大对象，会直接保存在老年代当中，如果老年代空间也不足，就会触发Full GC。为了避免这种情况，最好就是不要创建太大的对象。
- 持久代空间不足
    
	如果有持久代空间的话，系统当中需要加载的类，调用的方法很多，同时持久代当中没有足够的空间，就出触发一次Full GC
- YGC出现promotion failure
    
	promotion failure发生在Young GC, 如果Survivor区当中存活对象的年龄达到了设定值，会就将Survivor区当中的对象拷贝到老年代，如果老年代的空间不足，就会发生promotion failure， 接下去就会发生Full GC.
- 统计YGC发生时晋升到老年代的平均总大小大于老年代的空闲空间
      
	在发生YGC是会判断，是否安全，这里的安全指的是，当前老年代空间可以容纳YGC晋升的对象的平均大小，如果不安全，就不会执行YGC,转而执行Full GC。
- 显示调用System.gc

#### 28. Stop The World 了解过吗？ ####
29. 谈谈你认识多少种OOM？如何避免OOM?
#### 30. 了解过JVM调优没，基本思路是什么?如何确定它们的大小呢？ ####
	如果CPU使用率较高，GC频繁且GC时间长，可能就需要JVM调优了。基本思路就是让每一次GC都回收尽可能多的对象，对于CMS来说，要合理设置年轻代和年老代的大小。

	这是一个迭代的过程，可以先采用JVM的默认值，然后通过压测分析GC日志。
	- 如果看年轻代的内存使用率处在高位，导致频繁的Minor GC，而频繁GC的效率又不高，说明对象没那么快能被回收，这时年轻代可以适当调大一点。
	- 如果看年老代的内存使用率处在高位，导致频繁的Full GC，这样分两种情况：如果每次Full GC后年老代的内存占用率没有下来，可以怀疑是内存泄漏；如果Full GC后年老代的内存占用率下来了，说明不是内存泄漏，要考虑调大年老代。
	- 对于G1收集器来说，可以适当调大Java堆，因为G1收集器采用了局部区域收集策略，单次垃圾收集的时间可控，可以管理较大的Java堆。
#### 31. 淘宝热门商品信息在JVM哪个内存区域 ####
	淘宝的商品信息应该放到缓存中间件中。

#### 32. 字节码的编译过程 ####

![](https://camo.githubusercontent.com/0a536f5ee2b76163281bffa964f9c2ce9e3908a121b2a7d504836ef3b7833527/68747470733a2f2f757365722d676f6c642d63646e2e786974752e696f2f323032302f352f31342f313732306564613130393534636236623f773d3131323026683d35343926663d706e6726733d313238333135)


#### 33. Java需要开发人员回收内存垃圾吗？ ####
34. Java中垃圾回收有什么目的？什么时候进行垃圾回收？
#### 35. System.gc()和Runtime.gc()会做什么事情？ ####
这两个方法用来提示JVM要进行垃圾回收。但是，立即开始还是延迟进行垃圾回收是取决于jvm的。

#### 36. 主内存与工作内存 ####

主内存主要包括本地方法区和堆。每个线程都有一个工作内存(是一个逻辑概念，物理上并不存在)，工作内存中主要包括两个部分，一个是属于该线程私有的栈和对主存部分变量拷贝的寄存器(包括程序计数器PC和cup工作的高速缓存区)。

- 所有的变量都存储在主内存中(虚拟机内存的一部分)，对于所有线程都是共享的。
- 每条线程都有自己的工作内存，工作内存中保存的是主存中某些变量的拷贝，线程对变量的所有操作都必须在工作内存中进行，而不能直接读写主内存中的变量。
- 线程之间无法直接访问对方的工作内存中的变量，线程间变量的传递均需要通过主内存来完成。

#### 37. 内存间交互操作 ####
38. volatile 禁止内存重排序
39. 内存模型三大特性
40. 谈谈先行发生原则
#### 41. JVM 堆内存溢出后，其他线程是否可继续工作？ ####

堆内存是所有线程的共享内存，如果堆内存溢出，则所有线程都不能继续工作。虚拟机栈是线程私有的，如果栈内存溢出，则不影响其他线程继续工作。

#### 42. 说一下JVM 常用参数有哪些？ ####
43. JVM 为什么使用元空间替换了永久代？
44. Java堆的结构是什么样子的？什么是堆中的永久代(Perm Gen space)?
45. JVM的永久代中会发生垃圾回收么？
46. 什么是字节码？采用字节码的最大好处是什么？什么Java是虚拟机？
47. MinorGC 的过程
48. CPU 占用过高如何分析
49. Serial与Parallel GC之间的不同之处？
50. WeakHashMap 是怎么工作的？
51. 解释 Java 堆空间及 GC？
52. 你能保证 GC 执行吗？
53. JVM中哪个参数是用来控制线程的栈堆栈小的? ####
