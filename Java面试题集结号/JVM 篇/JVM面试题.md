### JVM 篇 ###
#### 1. 什么情况下会发生栈内存溢出。什么时候发生堆溢出？你是怎么排错的？  ####
- 栈内存溢出

	栈是线程私有的，他的生命周期与线程相同，每个方法在执行的时候都会创建一个栈帧，用来存储局部变量表，操作数栈，动态链接，方法出口等信息。局部变量表又包含基本数据类型，对象引用类型（局部变量表编译器完成，运行期间不会变化）。所以我们可以理解为栈溢出就是方法执行是创建的栈帧请求的深度超过了栈能给予的最大深度。最有可能的就是：递归方法调用产生这种结果。

	![](https://img-blog.csdnimg.cn/20200801195942598.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ZyaXN0amNqZG5jZw==,size_16,color_FFFFFF,t_70)

	解决：我们需要使用参数 -Xss 去调整JVM栈的大小

	![](https://img-blog.csdnimg.cn/20200801200243402.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ZyaXN0amNqZG5jZw==,size_16,color_FFFFFF,t_70)

- 堆内存溢出

	![](https://img-blog.csdnimg.cn/20200801200416915.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ZyaXN0amNqZG5jZw==,size_16,color_FFFFFF,t_70)

	（1）静态集合类，如HashMap、LinkedList等等。如果这些容器为静态的，那么它们的生命周期与程序一致，则容器中的对象在程序结束之前将不能被释放，从而造成内存泄漏。简单而言，长生命周期的对象持有短生命周期对象的引用，尽管短生命周期的对象不再使用，但是因为长生命周期对象持有它的引用而导致不能被回收。

	（2）数据库连接、网络连接和IO连接等。在对数据库进行操作的过程中，首先需要建立与数据库的连接，当不再使用时，需要调用close方法来释放与数据库的连接。只有连接被关闭后，垃圾回收器才会回收对应的对象。否则，如果在访问数据库的过程中，对Connection、Statement或ResultSet不显性地关闭，将会造成大量的对象无法被回收，从而引起内存泄漏。

	（3）变量不合理的作用域。一般而言，一个变量的定义的作用范围大于其使用范围，很有可能会造成内存泄漏。另一方面，如果没有及时地把对象设置为null，很有可能导致内存泄漏的发生。

	（4）对象被循环引用会导致堆内存溢出，在for循环里不断创建对象也会导致堆内存溢出，这种由于代码书写不当导致的内存溢出也叫内存泄漏，正常情况下大量的业务数据也会导致内存溢出，这种情况可以通过 -Xmx4096M 调整堆的总大小来解决，同时编写代码时也要注意存有大量数据的集合对象在使用完成后及时设置为null。

- 永久代溢出(OutOfMemoryError: PermGen space)
	由于JDK7、8移除永久带，所以上述代码在JDK1.6的情况中会出现永久带溢出的现象。

#### 2. JVM怎么判断对象是可回收对象？有哪些方法。 ####
- 引用计数法

    给每一个对象添加一个引用计数器，当一个引用指向对象，计数器值加一，当一个引用失效，计数器减一，判断计数器是否为0，确定对象是否可用。

- 可达性分析(Reachability Analysis) 

    从GC Roots开始搜索，关联到的对象存活，没有关联到的可以回收。

![](https://pic1.zhimg.com/80/v2-e980fa21a25bf85be0523f72d61d8d40_720w.jpg)
#### 3. 哪些对象可以作为GC Roots(Garbage Collection Roots)？ ####
- 虚拟机栈中引用的对象
- 方法区中类静态属性引用的对象
- 方法区中常量引用的对象
- 本地方法栈中JNI(native方法，调用C++代码)引用的对象
#### 4. JVM的内存结构，新生代与老年代的比例，Eden和Survivor比例。
JVM内存结果如图：
![](https://images2015.cnblogs.com/blog/1135193/201704/1135193-20170404105818910-121962267.jpg)

内存比例如图：
![](https://images0.cnblogs.com/blog/587773/201409/061921034534396.png)

从图中可以看出： 堆大小 = 新生代 + 老年代。其中，堆的大小可以通过参数 –Xms、-Xmx 来指定。
默认的，新生代 ( Young ) 与老年代 ( Old ) 的比例的值为 1:2 ( 该值可以通过参数 –XX:NewRatio 来指定 )，即：新生代 ( Young ) = 1/3 的堆空间大小。老年代 ( Old ) = 2/3 的堆空间大小。其中，新生代 ( Young ) 被细分为 Eden 和 两个 Survivor 区域，这两个 Survivor 区域分别被命名为 from 和 to，以示区分。
默认的，Eden : from : to = 8 : 1 : 1 ( 可以通过参数 –XX:SurvivorRatio 来设定 )，即： Eden = 8/10 的新生代空间大小，from = to = 1/10 的新生代空间大小。
JVM 每次只会使用 Eden 和其中的一块 Survivor 区域来为对象服务，所以无论什么时候，总是有一块 Survivor 区域是空闲着的。
因此，新生代实际可用的内存空间为 9/10 ( 即90% )的新生代空间。
#### 5. 你知道哪几种垃圾收集器，各自的优缺点，重点讲下cms和G1，包括原理，流程，优缺点。 ####
几种垃圾收集器：

Serial收集器：单线程的收集器，收集垃圾时，必须stop-the-world，使用复制算法。

ParNew收集器：Serial收集器的多线程版本，也需要stop-the-world，复制算法。

ParallelScavenge收集器：新生代收集器，复制算法的收集器，并发的多线程收集器，目标是达到一个 可控的吞吐量。如果虚拟机总共运行100分钟，其中垃圾花掉1分钟，吞吐量就是99%。

SerialOld收集器：是Serial收集器的老年代版本，单线程收集器，使用标记整理算法。

ParallelOld收集器：是ParallelScavenge收集器的老年代版本，使用多线程，标记-整理算法。

CMS(ConcurrentMarkSweep)收集器：是一种以获得最短回收停顿时间为目标的收集器，标记清除算法，运作过程：初始标记(stop-the-world)，并发标记，重新标记(stop-the-world)，并发清除。优点，并发执行，停顿时间短。缺点，收集结束会产生大量空间碎片。

G1收集器：标记整理算法实现，运作流程主要包括以下：初始标记(stop-the-world)，并发标记，最终标记(stop-the-world)，筛选回收(stop-the-world)。优点，(1) 基于标记-整理算法，不产生内存碎片。(2) 可以非常精确控制停顿时间，在不牺牲吞吐量前提下，实现低停顿垃圾回收。

G1 收集器避免全区域垃圾收集，它把堆内存划分为大小固定的几个独立区域，并且跟踪这些区域
的垃圾收集进度，同时在后台维护一个优先级列表，每次根据所允许的收集时间，优先回收垃圾
最多的区域。区域划分和优先级区域回收机制，确保 G1 收集器可以在有限时间获得最高的垃圾收
集效率。


#### 6. 简单说说你了解的类加载器，可以打破双亲委派么，怎么打破。 ####
- 简单说，类加载器根据指定的全限定名称将class文件加载到JVM内存，转为Class对象。

	类加载器主要分四种：
		**启动类加载器**（Bootstrap ClassLoader）：由C++语言实现（针对HotSpot）,负责将存放在<JAVA_HOME>\lib目录或-Xbootclasspath参数指定的路径中的类库加载到内存中。
		**扩展类加载器**（Extension ClassLoader）：负责加载<JAVA_HOME>\lib\ext目录或java.ext.dirs系统变量指定的路径中的所有类库。
		**应用程序类加载器**（Application ClassLoader）。负责加载用户类路径（classpath）上的指定类库，我们可以直接使用这个类加载器。一般情况，如果我们没有自定义类加载器默认就是用这个加载器。
		**自定义加载器**（Customer ClassLoader）。	**双亲委派模型工作过程**：如果一个类加载器收到类加载的请求，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器完成。每个类加载器都是如此，只有当父加载器在自己的搜索范围内找不到指定的类时（即ClassNotFoundException），子加载器才会尝试自己去加载。

- 打破双亲委派机制要继承ClassLoader类，并重写loadClass和findClass方法。默认的loadClass方法是实现了双亲委派机制的逻辑，即会先让父类加载器加载，当无法加载时才由自己加载。这里为了破坏双亲委派机制必须重写loadClass方法，即这里先尝试交由System类加载器加载，加载失败才会由自己加载。它并没有优先交给父类加载器，这就打破了双亲委派机制。

#### 7. JVM内存为什么要分成新生代，老年代，持久代。新生代中为什么要分为Eden和Survivor。 ####
8. JVM 出现 fullGC 很频繁，怎么去线上排查问题？
9. JVM中一次完整的GC流程是怎样的，对象如何晋升到老年代，说说你知道的几种主要的JVM参数。
10. 垃圾回收算法的实现原理。
11. JVM内存模型的相关知识了解多少，比如重排序，内存屏障，happen-before，主内存，工作内存等。
12. 说一下Java对象的创建过程
13. 你们线上应用的JVM参数配置了哪些。
#### 14. CMS和G1收集器的区别。 ####
CMS收集器是老年代的收集器，可以配合新生代的Serial和ParNew收 集器一起使用；G1收集器收集范围是老年代和新生代，不需要结合其他收集器使用；
CMS收集器以小的停顿时间为目标的收集器；G1收集器可预测垃圾回收的停顿时间CMS收集器是使用“标记-清除”算 法进行的垃圾回收，容易产生内存碎片G1收集器使用的是“标记-整理”算法，进行了空间整合，降低了内存空间碎片。

15. 怎么打出线程栈信息。
#### 16. 说一下类加载的执行过程 ####

JVM不是一开始就把所有的类都加载进内存中，而是只有第一次遇到某个需要运行的类时才会加载，且只加载一次。

类加载的过程主要分为三个部分：加载、链接、初始化。而链接又可以细分为三个小部分：验证、准备、解析。

**加载**

简单来说，加载指的是把class字节码文件从各个来源通过类加载器装载入内存中。

这里有两个重点：

字节码来源。一般的加载来源包括从本地路径下编译生成的.class文件，从jar包中的.class文件，从远程网络，以及动态代理实时编译

类加载器。一般包括启动类加载器，扩展类加载器，应用类加载器，以及用户的自定义类加载器。

注：为什么会有自定义类加载器？

一方面是由于java代码很容易被反编译，如果需要对自己的代码加密的话，可以对编译后的代码进行加密，然后再通过实现自己的自定义类加载器进行解密，最后再加载。

另一方面也有可能从非标准的来源加载代码，比如从网络来源，那就需要自己实现一个类加载器，从指定源进行加载。

**验证**

主要是为了保证加载进来的字节流符合虚拟机规范，不会造成安全错误。

包括对于文件格式的验证，比如常量中是否有不被支持的常量？文件中是否有不规范的或者附加的其他信息？

对于元数据的验证，比如该类是否继承了被final修饰的类？类中的字段，方法是否与父类冲突？是否出现了不合理的重载？

对于字节码的验证，保证程序语义的合理性，比如要保证类型转换的合理性。

对于符号引用的验证，比如校验符号引用中通过全限定名是否能够找到对应的类？校验符号引用中的访问性（private，public等）是否可被当前类访问？

**准备**

主要是为类变量（注意，不是实例变量）分配内存，并且赋予初值。

特别需要注意，初值，不是代码中具体写的初始化的值，而是Java虚拟机根据不同变量类型的默认初始值。

比如8种基本类型的初值，默认为0；引用类型的初值则为null；常量的初值即为代码中设置的值，final static tmp = 456， 那么该阶段tmp的初值就是456

**解析**

将常量池内的符号引用替换为直接引用的过程。

两个重点：

符号引用。即一个字符串，但是这个字符串给出了一些能够唯一性识别一个方法，一个变量，一个类的相关信息。

直接引用。可以理解为一个内存地址，或者一个偏移量。比如类方法，类变量的直接引用是指向方法区的指针；而实例方法，实例变量的直接引用则是从实例的头指针开始算起到这个实例变量位置的偏移量

举个例子来说，现在调用方法hello()，这个方法的地址是1234567，那么hello就是符号引用，1234567就是直接引用。

在解析阶段，虚拟机会把所有的类名，方法名，字段名这些符号引用替换为具体的内存地址或偏移量，也就是直接引用。

**初始化**

这个阶段主要是对类变量初始化，是执行类构造器的过程。

换句话说，只对static修饰的变量或语句进行初始化。

如果初始化一个类的时候，其父类尚未初始化，则优先初始化其父类。

如果同时包含多个静态变量和静态代码块，则按照自上而下的顺序依次执行。

#### 17. JVM垃圾回收机制，何时触发MinorGC等操作呢？ ####
18. ZGC 垃圾收集器，了解过吗
19. 对象的访问定位有哪两种方式?
20. 说一下 jvm 调优的工具？
21. 对象什么时候会进入老年代？
#### 22. 内存泄漏和内存溢出区别？ ####
- 内存溢出就是指程序运行过程中，申请的内存大于系统能够提供的内存，导致无法申请到足够的内存，就会发生内存溢出。
- 内存泄漏是指程序运行过程中分配内存给临时变量，用完之后却没有被GC回收，始终占用着内存，既不能被使用也不能分配给其他程序，就发生了内存泄漏。
#### 23. 什么是tomcat类加载机制？ ####
24. 了解逃逸分析技术吗
25. 调用System.gc()会发生什么?
26. 谈谈Minor GC条件，full GC条件
27. Stop The World 了解过吗？
28. 谈谈你认识多少种OOM？如何避免OOM?
29. 了解过JVM调优没，基本思路是什么?如何确定它们的大小呢？
30. 淘宝热门商品信息在JVM哪个内存区域
31. 字节码的编译过程
32. Java需要开发人员回收内存垃圾吗？
33. Java中垃圾回收有什么目的？什么时候进行垃圾回收？
#### 34. System.gc()和Runtime.gc()会做什么事情？ ####
这两个方法用来提示JVM要进行垃圾回收。但是，立即开始还是延迟进行垃圾回收是取决于jvm的。

35. 主内存与工作内存
36. 内存间交互操作
37. volatile 禁止内存重排序
38. 内存模型三大特性
39. 谈谈先行发生原则
40.  JVM 堆内存溢出后，其他线程是否可继续工作？
41.  说一下JVM 常用参数有哪些？
42.  VM 为什么使用元空间替换了永久代？
43.  Java堆的结构是什么样子的？什么是堆中的永久代(Perm Gen space)?
44.  JVM的永久代中会发生垃圾回收么？
45.  什么是字节码？采用字节码的最大好处是什么？什么Java是虚拟机？
46.  MinorGC 的过程
47.  CPU 占用过高如何分析
48.  Serial与Parallel GC之间的不同之处？
49.  WeakHashMap 是怎么工作的？
50.  解释 Java 堆空间及 GC？
51.  你能保证 GC 执行吗？
52.  JVM中哪个参数是用来控制线程的栈堆栈小的? ####
