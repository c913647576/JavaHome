### JVM 篇 ###
#### 1. 什么情况下会发生栈内存溢出。什么时候发生堆溢出？你是怎么排错的？  ####
> - 栈内存溢出
> 
> 	栈是线程私有的，他的生命周期与线程相同，每个方法在执行的时候都会创建一个栈帧，用来存储局部变量表，操作数栈，动态链接，方法出口等信息。局部变量表又包含基本数据类型，对象引用类型（局部变量表编译器完成，运行期间不会变化）。所以我们可以理解为栈溢出就是方法执行是创建的栈帧请求的深度超过了栈能给予的最大深度。最有可能的就是：递归方法调用产生这种结果。
> 
> 	![](https://img-blog.csdnimg.cn/20200801195942598.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ZyaXN0amNqZG5jZw==,size_16,color_FFFFFF,t_70)
> 
> 	解决：我们需要使用参数 -Xss 去调整JVM栈的大小
> 
> 	![](https://img-blog.csdnimg.cn/20200801200243402.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ZyaXN0amNqZG5jZw==,size_16,color_FFFFFF,t_70)
> 
> - 堆内存溢出
> 
> 	![](https://img-blog.csdnimg.cn/20200801200416915.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ZyaXN0amNqZG5jZw==,size_16,color_FFFFFF,t_70)
> 
> 	（1）静态集合类，如HashMap、LinkedList等等。如果这些容器为静态的，那么它们的生命周期与程序一致，则容器中的对象在程序结束之前将不能被释放，从而造成内存泄漏。简单而言，长生命周期的对象持有短生命周期对象的引用，尽管短生命周期的对象不再使用，但是因为长生命周期对象持有它的引用而导致不能被回收。
> 
> 	（2）数据库连接、网络连接和IO连接等。在对数据库进行操作的过程中，首先需要建立与数据库的连接，当不再使用时，需要调用close方法来释放与数据库的连接。只有连接被关闭后，垃圾回收器才会回收对应的对象。否则，如果在访问数据库的过程中，对Connection、Statement或ResultSet不显性地关闭，将会造成大量的对象无法被回收，从而引起内存泄漏。
> 
> 	（3）变量不合理的作用域。一般而言，一个变量的定义的作用范围大于其使用范围，很有可能会造成内存泄漏。另一方面，如果没有及时地把对象设置为null，很有可能导致内存泄漏的发生。
> 
> - 永久代溢出(OutOfMemoryError: PermGen space)
> 	由于JDK7、8移除永久带，所以上述代码在JDK1.6的情况中会出现永久带溢出的现象。

#### 2. JVM怎么判断对象是可回收对象？有哪些方法。 ####
> - 引用计数法
> 
>     给每一个对象添加一个引用计数器，当一个引用指向对象，计数器值加一，当一个引用失效，计数器减一，判断计数器是否为0，确定对象是否可用。
> 
> - 可达性分析(Reachability Analysis) 
> 
>     从GC Roots开始搜索，关联到的对象存活，没有关联到的可以回收。

![](https://pic1.zhimg.com/80/v2-e980fa21a25bf85be0523f72d61d8d40_720w.jpg)
#### 3. 哪些对象可以作为GC Roots(Garbage Collection Roots)？ ####
> - 虚拟机栈中引用的对象
> - 方法区中类静态属性引用的对象
> - 方法区中常量引用的对象
> - 本地方法栈中JNI(native方法，调用C++代码)引用的对象
#### 4. JVM的内存结构，新生代与老年代的比例，Eden和Survivor比例。
> JVM内存结果如图：
> ![](https://images2015.cnblogs.com/blog/1135193/201704/1135193-20170404105818910-121962267.jpg)
> 
> 内存比例如图：
> ![](https://images0.cnblogs.com/blog/587773/201409/061921034534396.png)
> 
> 从图中可以看出： 堆大小 = 新生代 + 老年代。其中，堆的大小可以通过参数 –Xms、-Xmx 来指定。
> 默认的，新生代 ( Young ) 与老年代 ( Old ) 的比例的值为 1:2 ( 该值可以通过参数 –XX:NewRatio 来指定 )，即：新生代 ( Young ) = 1/3 的堆空间大小。老年代 ( Old ) = 2/3 的堆空间大小。其中，新生代 ( Young ) 被细分为 Eden 和 两个 Survivor 区域，这两个 Survivor 区域分别被命名为 from 和 to，以示区分。
> 默认的，Eden : from : to = 8 : 1 : 1 ( 可以通过参数 –XX:SurvivorRatio 来设定 )，即： Eden = 8/10 的新生代空间大小，from = to = 1/10 的新生代空间大小。
> JVM 每次只会使用 Eden 和其中的一块 Survivor 区域来为对象服务，所以无论什么时候，总是有一块 Survivor 区域是空闲着的。
> 因此，新生代实际可用的内存空间为 9/10 ( 即90% )的新生代空间。
#### 5. 你知道哪几种垃圾收集器，各自的优缺点，重点讲下cms和G1，包括原理，流程，优缺点。 ####
> 几种垃圾收集器：
> 
> Serial收集器：单线程的收集器，收集垃圾时，必须stop-the-world，使用复制算法。
> 
> ParNew收集器：Serial收集器的多线程版本，也需要stop-the-world，复制算法。
> 
> ParallelScavenge收集器：新生代收集器，复制算法的收集器，并发的多线程收集器，目标是达到一个 可控的吞吐量。如果虚拟机总共运行100分钟，其中垃圾花掉1分钟，吞吐量就是99%。
> 
> SerialOld收集器：是Serial收集器的老年代版本，单线程收集器，使用标记整理算法。
> 
> ParallelOld收集器：是ParallelScavenge收集器的老年代版本，使用多线程，标记-整理算法。
> 
> CMS(ConcurrentMarkSweep)收集器：是一种以获得最短回收停顿时间为目标的收集器，标记清除算法，运作过程：初始标记(stop-the-world)，并发标记，重新标记(stop-the-world)，并发清除。优点，并发执行，停顿时间短。缺点，收集结束会产生大量空间碎片。
> 
> G1收集器：标记整理算法实现，运作流程主要包括以下：初始标记(stop-the-world)，并发标记，最终标记(stop-the-world)，筛选回收(stop-the-world)。优点，(1) 基于标记-整理算法，不产生内存碎片。(2) 可以非常精确控制停顿时间，在不牺牲吞吐量前提下，实现低停顿垃圾回收。
> 
> G1 收集器避免全区域垃圾收集，它把堆内存划分为大小固定的几个独立区域，并且跟踪这些区域
> 的垃圾收集进度，同时在后台维护一个优先级列表，每次根据所允许的收集时间，优先回收垃圾
> 最多的区域。区域划分和优先级区域回收机制，确保 G1 收集器可以在有限时间获得最高的垃圾收
> 集效率。

#### 6. 简单说说你了解的类加载器，可以打破双亲委派么，怎么打破。 ####
> - 简单说，类加载器根据指定的全限定名称将class文件加载到JVM内存，转为Class对象。
> 
> 	类加载器主要分四种：
> 		**启动类加载器**（Bootstrap ClassLoader）：由C++语言实现（针对HotSpot）,负责将存放在<JAVA_HOME>\lib目录或-Xbootclasspath参数指定的路径中的类库加载到内存中。
> 		**扩展类加载器**（Extension ClassLoader）：负责加载<JAVA_HOME>\lib\ext目录或java.ext.dirs系统变量指定的路径中的所有类库。
> 		**应用程序类加载器**（Application ClassLoader）。负责加载用户类路径（classpath）上的指定类库，我们可以直接使用这个类加载器。一般情况，如果我们没有自定义类加载器默认就是用这个加载器。
> 		**自定义加载器**（Customer ClassLoader）。	**双亲委派模型工作过程**：如果一个类加载器收到类加载的请求，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器完成。每个类加载器都是如此，只有当父加载器在自己的搜索范围内找不到指定的类时（即ClassNotFoundException），子加载器才会尝试自己去加载。
> 
> - 打破双亲委派机制要继承ClassLoader类，并重写loadClass和findClass方法。默认的loadClass方法是实现了双亲委派机制的逻辑，即会先让父类加载器加载，当无法加载时才由自己加载。这里为了破坏双亲委派机制必须重写loadClass方法，即这里先尝试交由System类加载器加载，加载失败才会由自己加载。它并没有优先交给父类加载器，这就打破了双亲委派机制。

#### 7. JVM内存为什么要分成新生代，老年代，持久代。新生代中为什么要分为Eden和Survivor。 ####

> **分代的作用**：因为有的对象寿命长，有的对象寿命短。应该将寿命长的对象放在一个区，寿命短的对象放在一个区。不同的区采用不同的垃圾收集算法。寿命短的区清理频次高一点，寿命长的区清理频次低一点。提高效率。
> 
> **Survivor的作用**：将Eden区满了的对象，添加到Survivor区，等对象反复清理几遍之后都没清理掉，再放到老年区，这样老年区的压力就会小很多。即Survivor相当于一个筛子，筛掉生命周期短的，将生命周期长的放到老年代区，减少老年代被清理的次数。
> 
> **为什么存在两个Survivor**:避免产生内存碎片。为了不产生内存碎片，才用复制算法，将Eden区和Survivor区存活的对象整齐的放到一个空的内存。因为生命周期一般都比较短，所以在存活对象不多的情况下，复制算法效率还是比较高的,这样就需要一个空内存，而如果有三个区，这样就总可以保持一个是空的，这样清理垃圾的时候，就可以将存活对象全部都整齐的放到一个空的内存中，不产生内存碎片了。

#### 8. JVM 出现 fullGC 很频繁，怎么去线上排查问题？ ####

> - jstat 查看GC信息观察GC后的堆空间大小并判断是否空间不足导致

> > > 空间不足导致：拿到 dump 文件，放入 JVisualVM 观察原因

> > > 空间充足：观察程序中有没显示调用 System.gc() 方法

#### 9. JVM中一次完整的GC流程是怎样的，对象如何晋升到老年代，说说你知道的几种主要的JVM参数。 ####

> 思路： 先描述一下Java堆内存划分，再解释Minor GC，Major GC，full GC，描述它们之间转化流程。
> 
> 我的答案：
> 
> Java堆 = 老年代 + 新生代
> 
> 新生代 = Eden + S0 + S1
> 
> 当 Eden 区的空间满了， Java虚拟机会触发一次 Minor GC，以收集新生代的垃圾，存活下来的对象，则会转移到 Survivor区。
> 
> 大对象（需要大量连续内存空间的Java对象，如那种很长的字符串）直接进入老年态；
> 
> 如果对象在Eden出生，并经过第一次Minor GC后仍然存活，并且被Survivor容纳的话，年龄设为1，每熬过一次Minor GC，年龄+1，若年龄超过一定限制（15），则被晋升到老年态。即长期存活的对象进入老年态。
> 
> 老年代满了而无法容纳更多的对象，Minor GC 之后通常就会进行Full GC，Full GC 清理整个内存堆 – 包括年轻代和年老代。
> 
> Major GC 发生在老年代的GC，清理老年区，经常会伴随至少一次Minor GC，比Minor GC慢10倍以上。

#### 10. 垃圾回收算法的实现原理。 ####

> 需要具体说明哪个垃圾回收算法；

#### 11. JVM内存模型的相关知识了解多少，比如重排序，内存屏障，happen-before，主内存，工作内存等。 ####
> 见36、37、38、39、40题；
#### 12. 说一下Java对象的创建过程 ####
> 对象创建首先是从new指令开始，jvm首先对符号引用进行解析，如果找不到对应的符号引用，说明这个类还没有被加载，因此jvm先进行类的记载过程。符号引用解析完毕后，jvm会为对象在堆中分配内存，HotSpot虚拟机实现的java对象包括三部分：对象头、实例字段和对齐填充字段（详见下图）。
> 
> ![](https://images2015.cnblogs.com/blog/592743/201603/592743-20160319235633553-1910724119.png)
> 
> 为对象分配完堆内存后，jvm会对该对象（除了对象头区域）进行零值初始化，这也就解释了为什么java的属性字段无需显示初始化就可以被使用，而方法的局部变量却必须要显示初始化后才可以访问。最后，jvm会调用对象的构造函数，当然，调用顺序一致上溯到Object类。
> 
> 至此，一个对象就被创建完毕，此时，一般会有一个引用指向这个对象。
> 对象创建的流程图如下：
> 
> ![](https://images2015.cnblogs.com/blog/592743/201603/592743-20160319235423381-1926278401.png)

#### 13. 你们线上应用的JVM参数配置了哪些。 ####
> 见42题
#### 14. CMS和G1收集器的区别。 ####
> CMS收集器是老年代的收集器，可以配合新生代的Serial和ParNew收 集器一起使用；G1收集器收集范围是老年代和新生代，不需要结合其他收集器使用；
> CMS收集器以小的停顿时间为目标的收集器；G1收集器可预测垃圾回收的停顿时间CMS收集器是使用“标记-清除”算 法进行的垃圾回收，容易产生内存碎片G1收集器使用的是“标记-整理”算法，进行了空间整合，降低了内存空间碎片。

#### 15. 怎么打出线程栈信息。 ####

> - jstack [pid] xxx.txt：打印堆栈信息到文件
> - jstack -l [pid] xxx.txt：打印堆栈信息（包含锁）到文件
> - kill -3
> - 添加 JVM 参数：-XX:+HEAPDUMPONOUTOFMEMORYERROR（在内存溢出是保存堆栈信息），一般配合 -XX:HeapDumpPath=PATH 使用（可用 jinfo 命令运行时修改）
> - jmap -dump:format=b,file=xxx.dump [pid]

#### 16. 说一下类加载的执行过程 ####

> JVM不是一开始就把所有的类都加载进内存中，而是只有第一次遇到某个需要运行的类时才会加载，且只加载一次。
> 
> 类加载的过程主要分为三个部分：加载、链接、初始化。而链接又可以细分为三个小部分：验证、准备、解析。
> 
> - **加载**
> 
> 简单来说，加载指的是把class字节码文件从各个来源通过类加载器装载入内存中。
> 
> 这里有两个重点：
> 
> 字节码来源。一般的加载来源包括从本地路径下编译生成的.class文件，从jar包中的.class文件，从远程网络，以及动态代理实时编译
> 
> 类加载器。一般包括启动类加载器，扩展类加载器，应用类加载器，以及用户的自定义类加载器。
> 
> 注：为什么会有自定义类加载器？
> 
> 一方面是由于java代码很容易被反编译，如果需要对自己的代码加密的话，可以对编译后的代码进行加密，然后再通过实现自己的自定义类加载器进行解密，最后再加载。
> 
> 另一方面也有可能从非标准的来源加载代码，比如从网络来源，那就需要自己实现一个类加载器，从指定源进行加载。
> 
> - **验证**
> 
> 主要是为了保证加载进来的字节流符合虚拟机规范，不会造成安全错误。
> 
> 包括对于文件格式的验证，比如常量中是否有不被支持的常量？文件中是否有不规范的或者附加的其他信息？
> 
> 对于元数据的验证，比如该类是否继承了被final修饰的类？类中的字段，方法是否与父类冲突？是否出现了不合理的重载？
> 
> 对于字节码的验证，保证程序语义的合理性，比如要保证类型转换的合理性。
> 
> 对于符号引用的验证，比如校验符号引用中通过全限定名是否能够找到对应的类？校验符号引用中的访问性（private，public等）是否可被当前类访问？
> 
> - **准备**
> 
> 主要是为类变量（注意，不是实例变量）分配内存，并且赋予初值。
> 
> 特别需要注意，初值，不是代码中具体写的初始化的值，而是Java虚拟机根据不同变量类型的默认初始值。
> 
> 比如8种基本类型的初值，默认为0；引用类型的初值则为null；常量的初值即为代码中设置的值，final static tmp = 456， 那么该阶段tmp的初值就是456
> 
> - **解析**
> 
> 将常量池内的符号引用替换为直接引用的过程。
> 
> 两个重点：
> 
> 符号引用。即一个字符串，但是这个字符串给出了一些能够唯一性识别一个方法，一个变量，一个类的相关信息。
> 
> 直接引用。可以理解为一个内存地址，或者一个偏移量。比如类方法，类变量的直接引用是指向方法区的指针；而实例方法，实例变量的直接引用则是从实例的头指针开始算起到这个实例变量位置的偏移量
> 
> 举个例子来说，现在调用方法hello()，这个方法的地址是1234567，那么hello就是符号引用，1234567就是直接引用。
> 
> 在解析阶段，虚拟机会把所有的类名，方法名，字段名这些符号引用替换为具体的内存地址或偏移量，也就是直接引用。
> 
> - **初始化**
> 
> 这个阶段主要是对类变量初始化，是执行类构造器的过程。
> 
> 换句话说，只对static修饰的变量或语句进行初始化。
> 
> 如果初始化一个类的时候，其父类尚未初始化，则优先初始化其父类。
> 
> 如果同时包含多个静态变量和静态代码块，则按照自上而下的顺序依次执行。

#### 17. JVM垃圾回收机制，何时触发MinorGC等操作呢？ ####

> 见27题

#### 18. ZGC 垃圾收集器，了解过吗 ####

> 有空学习，资料见 https://www.cnblogs.com/huanchupkblog/p/10947919.html
#### 19. 对象的访问定位有哪两种方式? ####

> - 句柄：在堆空间中开辟一块空间用来存放句柄池，句柄池存放对象的类型指针和对象的实例指针，reference指针指向句柄
> 
> 	**好处**：reference指向稳定的句柄，当堆空间进行gc时，对象的移动只会改变句柄中的对象实例指针，对reference没有影响
> 
> ![](https://images1.pianshen.com/224/91/91ec7710bde4593d2da392f40eac4558.png)
> 
> - 直接指针：堆中实例对象存放实例类型，reference指针直接指向实例对象
> 
> 	**好处**：速度更快，节省一次指针定位的开销

> ![](https://images3.pianshen.com/701/94/94f8585fd609ee64b0ec9bec634f0ff5.png)

#### 20. 类卸载条件？ ####

> 类卸载即该类的class对象被GC

> - 该类的所有的实例对象都被GC，即堆中不存在该类的实例对象

> - 该类没有在其他地方被引用

> - 该类的类加载器的实例已被GC

#### 21. 说一下 jvm 调优的工具？ ####
> JDK 自带了很多监控工具，都位于 JDK 的 bin 目录下，其中最常用的是 jconsole 和 jvisualVM 这两款视图监控工具。

> - jconsole：用于对 JVM 中的内存、线程和类等进行监控；

> - jvisualVM：JDK 自带的全能分析工具，可以分析：内存快照、线程快照、程序死锁、监控内存的变化、gc 变化等。

#### 22. 对象什么时候会进入老年代？ ####

> 思路： 先描述一下Java堆内存划分，再解释Minor GC，Major GC，full GC，描述它们之间转化流程。
> 
> 我的答案：
> 
> - Java堆 = 老年代 + 新生代
> - 新生代 = Eden + S0 + S1
> - 当 Eden 区的空间满了， Java虚拟机会触发一次 Minor GC，以收集新生代的垃圾，存活下来的对象，则会转移到 Survivor区。
> - 大对象（需要大量连续内存空间的Java对象，如那种很长的字符串）直接进入老年态；
> - 如果对象在Eden出生，并经过第一次Minor GC后仍然存活，并且被Survivor容纳的话，年龄设为1，每熬过一次Minor GC，年龄+1，若年龄超过一定限制（15），则被晋升到老年态。即长期存活的对象进入老年态。
> - 老年代满了而无法容纳更多的对象，Minor GC 之后通常就会进行Full GC，Full GC 清理整个内存堆 – 包括年轻代和年老代。
> - Major GC 发生在老年代的GC，清理老年区，经常会伴随至少一次Minor GC，比Minor GC慢10倍以上。

#### 23. 内存泄漏和内存溢出区别？ ####
> - 内存溢出就是指程序运行过程中，申请的内存大于系统能够提供的内存，导致无法申请到足够的内存，就会发生内存溢出。
> - 内存泄漏是指程序运行过程中分配内存给临时变量，用完之后却没有被GC回收，始终占用着内存，既不能被使用也不能分配给其他程序，就发生了内存泄漏。
#### 24. 什么是tomcat类加载机制？ ####
> Tomcat类加载打破了java的双亲委派机制，自定义了类加载器，使用Tomcat自定义的类加载器加载class时不会向上层委派，但其他的类加载器继续沿用java的双亲委派机制，因此不存在黑客通过编写恶意的HashMap等类对应用进行攻击。

> Tomcat类加载机制详见： https://www.cnblogs.com/aspirant/p/8991830.html
#### 25. 了解逃逸分析技术吗 ####
> 有空看，资料见 https://blog.csdn.net/ym15229994318ym/article/details/106543378

#### 26. 调用System.gc()会发生什么? ####

> 调用System.gc()方法会提示JVM进行Full GC垃圾回收。但是，立即开始还是延迟进行垃圾回收是取决于JVM的。在进行Full GC之前会先进行Minor GC。
#### 27. 谈谈Minor GC条件，full GC条件 ####

> **触发MinorGC(Young GC)**

> 虚拟机在进行minorGC之前会判断老年代最大的可用连续空间是否大于新生代的所有对象总空间
> 
> - 如果大于的话，直接执行minorGC
> - 如果小于，判断是否开启HandlerPromotionFailure（分配担保机制），没有开启直接FullGC
> - 如果开启了HanlerPromotionFailure, JVM会判断老年代的最大连续内存空间是否大于历次晋升的大小，如果小于直接执行FullGC
> - 如果大于的话，执行minorGC
> 
> **触发FullGC**
> 
> - 老年代空间不足
> 
>      如果创建一个大对象，Eden区域当中放不下这个大对象，会直接保存在老年代当中，如果老年代空间也不足，就会触发Full GC。为了避免这种情况，最好就是不要创建太大的对象。
> - 持久代空间不足
>     
> 	如果有持久代空间的话，系统当中需要加载的类，调用的方法很多，同时持久代当中没有足够的空间，就出触发一次Full GC
> - YGC出现promotion failure
>     
> 	promotion failure发生在Young GC, 如果Survivor区当中存活对象的年龄达到了设定值，会就将Survivor区当中的对象拷贝到老年代，如果老年代的空间不足，就会发生promotion failure， 接下去就会发生Full GC.
> - 统计YGC发生时晋升到老年代的平均总大小大于老年代的空闲空间
>       
> 	在发生YGC是会判断，是否安全，这里的安全指的是，当前老年代空间可以容纳YGC晋升的对象的平均大小，如果不安全，就不会执行YGC,转而执行Full GC。
> - 显示调用System.gc

#### 28. Stop The World 了解过吗？ ####

> 所谓的Stop the World机制，简称STW，即在执行垃圾收集算法时，java应用程序的所有线程被挂起。此时，系统只能允许GC线程运行，其他线程则会全部暂停，等待GC线程执行完毕后才能继续运行。

#### 29. 谈谈你认识多少种OOM？如何避免OOM? ####

- Java.lang.OutOfMemoryError:Java heap space
> 堆内存溢出，通过设置参数-Xmx指定一个更大的堆空间，但是我们也不可能一直调大堆内存，因此，我们可以使用一些内存分析工具，比如MAT，Visual VM工具来查看对象的创建情况，查看是否存在内存泄漏，优化代码，回收无用的对象。

- Java.lang.OutOfMemeoryError:GC overhead limit exceeded
> 如果堆内存控件太小，那么GC所占的时间就会变多，回收所释放的内存也会比较少，虚拟机在评估GC的效率时会认为GC的效率过低而抛出此异常。不过虚拟机不会随意的判定，虚拟机主要检查以下几种情况：
> 

> - 花在GC上的时间是否超过了98%
> 

> - 老年代释放的内存是否小于2%
> 

> - Eden区释放的内存是否小于2%
> 

> - 最近是否连续5次出现都出现上述情况
> 
> 出现此异常需要通过调大堆内存来解决

- Java.lang.OutOfMemeoryError:unable to create new native thread
> 原因： 应用创建了太多线程，超出了系统承载极限（Linux默认1024）；
> 
> 解决： 使用线程池管理线程，降低创建线程的数量，对于确实需要创建很多线程的情况，需要修改Linux配置扩大限制；

- Java.lang.OutOfMemeoryError:Metaspace
> 元空间是jdk1.8后方法去在Hotspot的实现，使用的是直接内存，出现此异常需要增大元空间大小。
#### 30. 了解过JVM调优没，基本思路是什么?如何确定它们的大小呢？ ####
> - 如果CPU使用率较高，GC频繁且GC时间长，可能就需要JVM调优了。基本思路就是让每一次GC都回收尽可能多的对象，对于CMS来说，要合理设置年轻代和年老代的大小。
> - 这是一个迭代的过程，可以先采用JVM的默认值，然后通过压测分析GC日志。
> 
> 	1. 如果看年轻代的内存使用率处在高位，导致频繁的Minor GC，而频繁GC的效率又不高，说明对象没那么快能被回收，这时年轻代可以适当调大一点。
> 	1. 如果看年老代的内存使用率处在高位，导致频繁的Full GC，这样分两种情况：如果每次Full GC后年老代的内存占用率没有下来，可以怀疑是内存泄漏；如果Full GC后年老代的内存占用率下来了，说明不是内存泄漏，要考虑调大年老代。
> 	1. 对于G1收集器来说，可以适当调大Java堆，因为G1收集器采用了局部区域收集策略，单次垃圾收集的时间可控，可以管理较大的Java堆。
#### 31. 淘宝热门商品信息在JVM哪个内存区域 ####
> 淘宝的商品信息应该放到缓存中间件中。
#### 32. 字节码的编译过程 ####

![](https://camo.githubusercontent.com/0a536f5ee2b76163281bffa964f9c2ce9e3908a121b2a7d504836ef3b7833527/68747470733a2f2f757365722d676f6c642d63646e2e786974752e696f2f323032302f352f31342f313732306564613130393534636236623f773d3131323026683d35343926663d706e6726733d313238333135)


#### 33. Java需要开发人员回收内存垃圾吗？ ####
> 不需要
#### 34. Java中垃圾回收有什么目的？什么时候进行垃圾回收？ ####
> 回收堆中存在没有引用的对象或超过作用域的对象，释放资源。
> 
> 回收时间：当对象失去引用后，系统会在合适的时间回收它所占的内存。
> 
> 回收时间即出发GC的时间。
> 
> 在新生代的Eden区满了会触发新生代GC（MiMor GC），经过多次触发新生代GC存活下来的对象就会升级到老年代，升级到老年代的对象所需要的内存大于老年代剩余内存，则会触发老年代GC（Full GC）。
> 
> 当程序调用System.gc()时也会触发Full GC。

#### 35. System.gc()和Runtime.gc()会做什么事情？ ####

> 这两个方法用来提示JVM要进行垃圾回收。但是，立即开始还是延迟进行垃圾回收是取决于jvm的。

#### 36. 主内存与工作内存 ####

> 主内存主要包括本地方法区和堆。每个线程都有一个工作内存(是一个逻辑概念，物理上并不存在)，工作内存中主要包括两个部分，一个是属于该线程私有的栈和对主存部分变量拷贝的寄存器(包括程序计数器PC和cup工作的高速缓存区)。

> - 所有的变量都存储在主内存中(虚拟机内存的一部分)，对于所有线程都是共享的。

> - 每条线程都有自己的工作内存，工作内存中保存的是主存中某些变量的拷贝，线程对变量的所有操作都必须在工作内存中进行，而不能直接读写主内存中的变量。

> - 线程之间无法直接访问对方的工作内存中的变量，线程间变量的传递均需要通过主内存来完成。

#### 37. 内存间交互操作 ####
> Javan内存模型定义了8种操作来完成主内存与工作内存的读写交互，虚拟机实现保证每一种操作都是原子的，不可再分的

> Lock锁定	 &emsp;&emsp;作用于主内存变量，将变量标志为一条线程所独占
> 
> Unlock解锁	 &emsp;&emsp;作用于主内存变量，将处于锁定的变量释放出来
> 
> Read读取	&emsp;&emsp;作用于主内存变量，它将一个变量的值从主内存传输到线程的工作内存中
> 
> Load载入	&emsp;&emsp;作用于工作内存变量，它把从主内存读取的变量值放入工作内存的副本中
> 
> Use使用	&emsp;&emsp;作用于工作内存变量，将工作内存变量值传递给执行引擎
> 
> Assgin赋值	&emsp;&emsp;作用于工作内存变量，将执行引擎的值传递给工作内存的变量
> 
> Store存储	&emsp;&emsp;作用于工作内存变量，它把工作内存变量传递到主内存中
> 
> Write写入	&emsp;&emsp;作用于主内存变量，把Store操作从工作内存得到的变量值放入主内存变量中

> - 如果要把一个变量的值从主内存复制到工作内存，那么需要执行read load操作

> - 如果要把一个变量的值从工作内存同步回主内存，那么需要执行store write操作


> Java内存模型这2个操作必须顺序执行，但不保证连续执行，即在指令之间可以插入其它指令

> 但是Java内存模型规定了一些必要的规则

> - 不允许read load    store write单独出现，即不允许一个变量读取到工作内存，但没有变量接收的情况
> - 不允许一个线程丢弃它的assign操作，即变量在工作内存改变必须同步回主内存
> - 不允许一个线程无原因（没有发生assgin赋值操作）把数据从线程的工作内存同步会主内存
> - 一个新的变量只能在主内存中诞生，不允许在工作内存中直接使用未被初始化的变量
> - 一个变量同一时刻只允许一条线程对其进行Lock锁定，但Lock操作可以被同一线程重复执行
> - 如果对一个变量执行Lock锁定，会清空工作内存中该副本的值，即执行引擎使用该值会重新load assgin操作初始化该值
> - 如果一个变量事先没有被Lock锁定，那就不允许进行Unlock操作，也不允许Unlock其它线程锁定的变量
> - 对一个变量执行Unlock操作，必须先把此变量值同步回主内存（store write操作）

> 这些规定确保了一些基本的并发操作的一致性
#### 38. volatile 禁止指令重排序 ####
> voliate关键字的两个作用：1、 保证变量的内存可见性；2、 禁止指令重排序；
> 
> **指令重排**：处理器为了提高程序运行效率，可能会对输入代码进行优化，它不保证程序各个语句的执行顺序和代码中的顺序一致，但是它保证最终执行结果和代码顺序执行的结果是一致的。重排序过程不会影响到单线程程序的执行，却会影响到多线程并发执行的正确性。
> 
> 源代码 -> 编译器优化的重排 ->指令并行的重排 -> 内存系统的重排 -> 最终执行的指令
> 
#### 39. 内存模型(JMM)三大特性 ####

> 三大特性分别是**原子性**，**可见性**，**有序性**
> 
> **原子性**：指一个操作是不可中断的，要么成功要么失败，失败的时候恢复到操作之前的状态，即使是多个线程一起执行的时候，一个操作一旦开始，就不会被其他线程干扰。
> 
> **可见性**：指当一个线程修改了某一个共享变量的值，其他线程是否能够立即知道这个修改。
> 
> **有序性**：对于一个线程的执行代码而言，我们总是习惯地认为代码的执行时从先往后，依次执行的。但是在并发时，程序的执行可能就会出现乱序。给人直观的感觉就是：写在前面的代码，会在后面执行。有序性问题的原因是因为程序在执行时，可能会进行指令重排，重排后的指令与原指令的顺序未必一致

> volatile只能保证可见性，也可以保证单次读/写的原子性，如 long 和 double 类型变量，但是并不能保证 i++这种操作的原子性，因为本质上 i++是读、写两次操作。synchronized可以保证原子性、可见性及有序性。volatile在某些场景下可以代替 Synchronized。但是,volatile 的不能完全取代 Synchronized 的位置，只有在一些特殊的场景下，才能适用 volatile。总的来说，必须同时满足下面两个条件才能保证在并发环境的线程安
全：（1）对变量的写操作不依赖于当前值（比如 i++），或者说是单纯的变量赋值（boolean
flag = true） 。（2）该变量没有包含在具有其他变量的不变式中， 也就是说，不同的 volatile 变量之间，不能互相依赖。 只有在状态真正独立于程序内其他内容时才能使用 volatile。
> 
#### 40. 谈谈先行发生原则（happen-before） ####
> 
#### 41. JVM 堆内存溢出后，其他线程是否可继续工作？ ####

> 当一个线程抛出OOM异常后，他所占据的内存资源会全部被释放掉，从而不会影响其他线程的运行。如果是栈溢出，结论也是一样的。

#### 42. 说一下JVM 常用参数有哪些？ ####
- 堆栈配置相关
> java -Xmx3550m -Xms3550m -Xmn2g -Xss128k 
-XX:MaxPermSize=16m -XX:NewRatio=4 -XX:SurvivorRatio=4 -XX:MaxTenuringThreshold=0
> -Xmx3550m： 最大堆大小为3550m。
> 
> -Xms3550m： 设置初始堆大小为3550m。
> 
> -Xmn2g： 设置年轻代大小为2g。
> 
> -Xss128k： 每个线程的堆栈大小为128k。
> 
> -XX:MaxPermSize： 设置持久代大小为16m
> 
> -XX:NewRatio=4: 设置年轻代（包括Eden和两个Survivor区）与年老代的比值（除去持久代）。
> 
> -XX:SurvivorRatio=4： 设置年轻代中Eden区与Survivor区的大小比值。设置为4，则两个Survivor区与一个Eden区的比值为2:4，一个Survivor区占整个年轻代的1/6
> 
> -XX:MaxTenuringThreshold=0： 设置垃圾最大年龄。如果设置为0的话，则年轻代对象不经过Survivor区，直接进入年老代。

- 垃圾收集器相关

> -XX:+UseParallelGC： 选择垃圾收集器为并行收集器。
> 
> -XX:ParallelGCThreads=20： 配置并行收集器的线程数
> 
> -XX:+UseConcMarkSweepGC： 设置年老代为并发收集。
> 
> -XX:CMSFullGCsBeforeCompaction：由于并发收集器不对内存空间进行压缩、整理，所以运行一段时间以后会产生“碎片”，使得运行效率降低。此值设置运行多少次GC以后对内存空间进行压缩、整理。
> 
> -XX:+UseCMSCompactAtFullCollection： 打开对年老代的压缩。可能会影响性能，但是可以消除碎片
#### 43. JVM 为什么使用元空间替换了永久代？ ####

> 原因：字符串常量池存在于永久代中，在大量使用字符串的情况下，非常容易出现OOM异常。此外，JVM加载的class的总数，方法的大小等都很难确定，因此对永久代大小的指定难以确定。太小的永久代容易导致永久代内存溢出，太大的永久代则容易导致虚拟机内存紧张。
> 
> 方法区是一种规范，不同的虚拟机厂商可以基于规范做出不同的实现，永久代和元空间就是出于不同jdk版本的实现。

> 说白了，方法去就像是一个接口，永久代与元空间分别是两个不同的实现类而已。只不过永久代是这个接口最初的实现类，后来这个接口一直进行变更，直到最后彻底废弃这个实现类，由新实现类——元空间进行替代。方法区和堆一样，是各个线程共享的内存区域，他用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译后的代码等数据。java7时，把字符串常量池（interned strings）和类静态变量（class statics）转移到了java heap。java8开始，永久代就已经消失了，由元空间取而代之。

#### 44. Java堆的结构是什么样子的？什么是堆中的永久代(Perm Gen space)? ####

> 堆结构见4题。另外永久代不存在与堆中。

#### 45. JVM的永久代中会发生垃圾回收么？ ####

> 垃圾回收不会发生在永久代，如果永久代满了或者是超过了临界值，会触发完全垃圾回收(Full GC)。如果你仔细查看垃圾收集器的输出信息，就会发现永久代也是被回收的。这就是为什么正确的永久代大小对避免Full GC是非常重要的原因。

#### 46. 什么是字节码？采用字节码的最大好处是什么？什么Java是虚拟机？ ####

> 在Java中，将虚拟机可以读懂的代码，称之为字节码。采用字节码的最大好处是可以实现一次编译到处运行，也就是java的平台无惯性。为了运行java代码而虚拟出来的类似于计算机的java代码执行引擎叫java虚拟机。

#### 47. MinorGC 的过程 ####

> 1. 对象的内存分配主要在新生代的Eden区和From Survivor区，少数情况会直接分配到老生代。
> 1. 当新生代的Eden区和From Survivor区空间不足时就会发生一次GC，进行GC后，Eden区和From Survivor区的存活对象会被挪到To Survivor区，然后将Eden区和From Survivor区进行清理（如果To Survivor区无法足够存储某个对象，则将这个对象存储到老生代）。
> 1. 将From Survivor区和to Survivor区进行交换。
> 1. 如此反复循环。
> 1. 当对象在Survivor区进行一次GC后，其年龄就会+1。默认情况下年龄到达15的对象会被移到老年代中。

#### 48. CPU 占用过高如何分析 ####
&emsp;&emsp;在实际开发过程中，我们经常遇到cup突然飙升，这个时候我们要怎么分析，是项目中的那一行代码导致的呢？

假如有下面一段程序

    import java.util.ArrayList;
    import java.util.List;
    import java.util.Random;
     
    /**
     * @Author: wu.yj
     * @Description:
     * @Date: 2020/3/24 9:44
     */
    public class TestCpu {
	    public static void main(String[] args) {
	    	List<Integerlist = new ArrayList<>();
	    	int count = 0;
	    	while (true) {
	    		double random = Math.random();
	    		list.add((int) random * 1000000);
	    		System.out.println(++ count);
	    	}
	    }
    }

&emsp;&emsp;这段程序我们在linux中运行，会不断的打印一串串的数字，这个时候cpu的使用一直飙升，下面我们讲一下如何分析：

1、先使用top命令；

![](https://img-blog.csdnimg.cn/20200324221610418.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3d3d3d3dzMz,size_16,color_FFFFFF,t_70)

首先看下用红色圈圈标记的分别是啥含义：
> linux系统当前时间

> 从开机到目前运行了多久，

> 当前有几个用户连接到本台主机

> 负载均衡，当三个值（这三个值分别为：1分钟平均负载、5分钟平均负载、15 分钟平均负载）相加后除以3结果大于0.6表示需要注意服务器负担。

> cpu使用率

> 80.6%id，该id是system idle process=处理器空闲时间百分比，越大越好

> Swap，交换分区的值

由上图可知，java程序占用cpu过高的进程是10908

2、进一步定位到具体的线程和代码

`ps -mp 进程号 -o THREAD,tid,time`

![](https://img-blog.csdnimg.cn/20200324222049267.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3d3d3d3dzMz,size_16,color_FFFFFF,t_70)

以上命令参数解释：

> -m 显示所有的线程

> -p pid 进程使用cpu的时间

> -o 该参数后是用户自定义的格式

从上面可以得出，是由于线程id 为10909（转化为十六进制小写）的线程导致cup占用过高；

3、查看具体的代码，使用 jstack 进程ID | grep tid(十六进制线程ID小写英文) -A80

![](https://img-blog.csdnimg.cn/2020032422254553.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3d3d3d3dzMz,size_16,color_FFFFFF,t_70)

从上图我们就知道导致cup过高是由于TestCup这个类中19行代码导致的；
#### 49. Serial与Parallel GC之间的不同之处？ ####
> Serial与Parallel GC使用的都是复制算法，Serial执行 GC 的时候只有一个线程，而parallel 收集器使用多个 GC 线程来执行。
#### 50. WeakHashMap 是怎么工作的？ ####
> 略
#### 51. 你能保证 GC 执行吗？ ####
> 不能保证GC执行，虽然可以通过调用System.gc()或者调用Runtime.gc()进行垃圾回收，但是只是提示JVM进行垃圾回收，并不能保证GC的执行。
#### 52. 三色标记法、多标和漏标 ####
> **什么是三色标记**
> 
> 三色标记是在cms和g1中使用的垃圾追踪算法
> 
- 黑色
> > > 从GCRoots开始,已扫描过它全部引用的对象,标记为黑
> 
- 灰色
> > > 扫描过对象本身,还没完全扫描过它全部引用的对象,标记为灰色
> 
- 白色
> > > 还没扫描过的对象,标记为白色
> 
> 所以,从GCRoots开始,顺着一直向下扫描,用可达性分析算法,最后所有的白色对象,都是垃圾对象,可以回收
> 
> **三色标记的漏标问题**
> 
> 我们采用一个最简单的模型,只有三个对象
> 
> 1. 某个状态下,黑色->灰色->白色

![](https://img-blog.csdnimg.cn/20200801000649461.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMyMzEwMTc1,size_16,color_FFFFFF,t_70)

> 2. 如果一切顺利,不发生任何引用变化,gc线程顺着灰色的引用向下扫描,最后都变成黑色,都是存活对象

![](https://img-blog.csdnimg.cn/20200801000741141.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMyMzEwMTc1,size_16,color_FFFFFF,t_70)

> 3. 但是如果出现了这样一个状况,在扫描到灰色的时候,还没有扫描到这个白色对象,此时,黑色对象引用了这个白色对象,而灰色对象指向了别人,或者干脆指向了null,也就是取消了对白色对象的引用

![](https://img-blog.csdnimg.cn/20200801000752674.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMyMzEwMTc1,size_16,color_FFFFFF,t_70)

> 4. 那么我们会发现一个问题,根据三色标记规则,gc会认为,黑色对象是本身已经被扫描过,并且它所有指向的引用都已经被扫描过,所以不会再去扫描它有哪些引用指向了哪些对象然后,灰色对象因为取消了对白色对象的引用,所以后面gc开始扫描所有灰色对象的引用时候,也不会再扫描到白色对象最后结果就是,白色对象直到本次标记扫描结束,也是白色,根据三色标记规则,认为它是垃圾,被清理掉但是实际情况,它明显是被引用的对象,是绝对不能当做垃圾来清除的,因为漏标,最后被当垃圾清理掉了。

![](https://img-blog.csdnimg.cn/20200801000834405.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMyMzEwMTc1,size_16,color_FFFFFF,t_70)

> **漏标的两个充要条件**

> - 所有的灰色对象在自己引用扫描完成之前删除了对白色对象的引用

> - 至少有一个黑色对象在自己被标记之后指向了这个白色对象
> 这两个条件,必须全满足,才会造成漏标问题.
> 
> 换言之,我们破坏任何一个条件.这个白色对象,就不会再被漏标
> 
> 这样就产生了两个解决办法

> **G1采用的是原始快照**

> 原始快照破坏的是第一个条件,我们在这个灰色对象取消对白色对象的引用之前,将这个引用记录下来,在最后标记的时候,再以这个引用指向的白色对象为根,对它的引用进行扫描。可以简单理解为,当一个灰色对象取消了对白色对象的引用,那么这个白色对象被变灰。 这样做的缺点就是,这个白色对象有可能并没有黑色对象去引用它,但是它还是被变灰了,就会导致它和它的引用,本来应该被垃圾回收掉,但是此次GC存活了下来,就是所谓的浮动垃圾.其实这样是比较可以忍受的,只是让它多存活了一次GC而已,浪费一点点空间,但是会比增量更新更省时间.

> **CMS采用的是增量更新**

> 增量更新破坏的是第二个条件,我们在这个黑色对象增加了对白色对象的引用之后,将它的这个引用,记录下来,在最后标记的时候,再以这个黑色对象为根,对它的引用进行重新扫描。可以简单理解为,当一个黑色对象增加了对白色对象的引用,那么这个黑色对象就被变灰。这样有一个缺点,就是会重新扫描这个黑色对象的所有引用,比较浪费时间。

> **三色标记的多标问题**

> 假设已经遍历到E（变为灰色了），此时对象D取消了对E对象的引用。

![](https://upload-images.jianshu.io/upload_images/7779607-7a5ce353116237e2.png?imageMogr2/auto-orient/strip|imageView2/2/w/683/format/webp)

> 此刻之后，对象E/F/G是“应该”被回收的。然而因为E已经变为灰色了，其仍会被当作存活对象继续遍历下去。最终的结果是：这部分对象仍会被标记为存活，即本轮GC不会回收这部分内存。这部分本应该回收 但是 没有回收到的内存，被称之为“浮动垃圾”。浮动垃圾并不会影响应用程序的正确性，只是需要等到下一轮垃圾回收中才被清除。另外，针对并发标记开始后的新对象，通常的做法是直接全部当成黑色，本轮不会进行清除。这部分对象期间可能会变为垃圾，这也算是浮动垃圾的一部分。

